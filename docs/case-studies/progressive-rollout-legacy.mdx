import ProgressiveRoutingDemo from '@site/src/components/prog-rollout/progressive-routing-demo';
import CodeHeader from '@site/src/components/docs/code-header';

# Progressive Rollout from Legacy to NextGen Stack (Hybrid Routing)

:::info Core Objective
Modernize without freezing delivery or risking route uptime.
:::

:::tip Live Demo Available
Short on time? Jump directly to the [interactive demo](#live-demo).
:::

## Summary

This case study shows a production-style migration strategy where one URL can be served by either a legacy Hapi controller or a NextGen React Router runtime, with controlled rollout and safe fallback.

:::note Transparency Disclaimer
The documentation scaffolding and page implementation were generated with AI assistance and should not be evaluated as original authored product code.
In this case study, the core authored implementation is represented by:
`server/init/routes.mjs`,
`nextgen-app/routes.ts`,
`nextgen-app/hybrid-routing/paths.ts`,
`nextgen-app/hybrid-routing/routing.ts`,
`nextgen-app/hybrid-routing/vite.ts`,
`nextgen-app/hybrid-routing/fake-feature-flag.ts`
`server/demo-runtime-services.mjs` (entry point for the demo server init and vite middlewares/assets routing)
:::

## Problem to Solve

I needed to ship a modern stack incrementally while keeping legacy pages stable and revenue-safe.

I needed surgical control over rollout blast radius:

1. Existing URLs could not change.
2. Legacy had to remain the source of safety.
3. Rollout had to be reversible instantly.
4. Failures in NextGen had to degrade gracefully.
5. Observability had to be explicit to prove routing decisions in real traffic.

## Main Risks Covered

1. Routing regressions during migration.
2. Hard cutover risk (all-or-nothing releases).
3. Runtime failures in NextGen breaking user journeys.
4. Operational blind spots (not knowing why a request went legacy vs NextGen).
5. Fragmented data behavior between old and new renderers.

## Architectural Approach

The solution uses a route-level resolver (`resolveRouteController`) that composes both worlds behind the same path.

1. Hapi keeps owning route registration and legacy controllers.
2. Resolver checks feature-flag and path eligibility.
3. If eligible, it delegates to a React Router handler adapted to Hapi request/response.
4. If not eligible, it serves legacy immediately.
5. If NextGen fails, it falls back to legacy path safely.

This avoids dual public endpoints, keeps migration localized, and preserves rollback.

## End-to-End Request Flow

1. Request enters Hapi route table.
2. `resolveRouteController(...)` runs for dual-stack paths.
3. `shouldUseNextGenRouter(request)` evaluates flag + route match + fallback query.
4. NextGen branch: load React Router server build through Vite middleware mode and respond through the Hapi adapter.
5. Legacy branch: execute legacy controller handler directly.
6. Decision and reason are emitted to routing events for debugging and auditability.

## Key Files (Entry Point to Runtime)

All files below live in the companion runtime repo used by this demo ([`hybrid-routing-demo`](https://github.com/cromagnoli/hybrid-routing-demo)).

### 1) Route registration entry

<CodeHeader
  path="server/init/routes.mjs"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/server/init/routes.mjs#L20"
/>

```js
const routes = [
  {
    method: "GET",
    path: "/cdp/{productCategory}/",
    config: cdp.get,
  },
  {
    method: "GET",
    path: "/pdp/{productCategory}/{productName}/{productId}/",
    config: routing.resolveRouteController(
      pdp.getLegacy,
      "/pdp/{productCategory}/{productName}/{productId}/"
    ),
  },
  {
    method: "GET",
    path: "/checkout/",
    config: checkout.get,
  },
  {
    method: ["GET", "POST"],
    path: "/{path*}",
    config: routing.resolveRouteController(fallback.unmatched, "/{path*}"),
  },
];
```

:::note Why it matters
Only dual-stack routes use `resolveRouteController()`; legacy-only routes keep direct controllers.
:::

### 2) Core hybrid resolver

#### 2.1) Main entry point (`resolveRouteController`)

<CodeHeader
  path="nextgen-app/hybrid-routing/routing.ts"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/hybrid-routing/routing.ts#L78"
/>
```js
export const resolveRouteController = (legacyController: ServerRoute, pathDebugId: string) => ({
  ...legacyController,
  handler: async (...handlerArgs) => {
    try {
      const [request] = handlerArgs;

      if (shouldUseNextGenRouter(request)) {
        logger.info('resolveRouteController', 'Running modern routing for', [
          request?.method?.toUpperCase(),
          request?.url?.href,
          serializeLogSegment({ pathDebugId })
        ]);

        const reactRouterRoutesHandler = await getReactRouterRoutesHandler(request);

        return reactRouterRoutesHandler(...handlerArgs);
      }

      logger.info('resolveRouteController', 'Running legacy routing for', [
        request?.method?.toUpperCase(),
        request?.url?.href,
        serializeLogSegment({ pathDebugId })
      ]);

      if (typeof legacyController.handler === 'function') {
        return legacyController.handler(...handlerArgs);
      }

      throw new Error('Handler is undefined for legacyController');
    } catch (error) {
      logger.error(
        'resolveRouteController',
        'Failure resolving Hapi/ReactRouter route handler. Routing to Hapi 404 page...',
        [serializeLogSegment(error)]
      );

      return notFound.handler(...handlerArgs);
    }
  }
});
```

#### 2.2) Eligibility gate used by the resolver

:::note Feature-flag route metadata (conceptual)
```js
// In production, this route allowlist is controlled by the feature-flag platform.
// For demo purposes, this implementation keeps it local and explicit.
const NEXTGEN_ENABLED_ROUTES = ["ProductDetail"];
```
:::

<CodeHeader
    path="nextgen-app/hybrid-routing/routing.ts"
    href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/hybrid-routing/routing.ts#L133"
/>
```js
const shouldUseNextGenRouter = (request) => {
  const hasLegacyFallbackQuery = request?.url?.searchParams?.get("legacy");

  if (hasLegacyFallbackQuery) {
    return false;
  }

  const context = parseContext(request);
  const isPathAvailable = isNextGenPathAvailable(request.path, NEXTGEN_ENABLED_ROUTES);

  return isNextGenRoutingEnabled(context) && isPathAvailable;
};
```

:::note Why `hasLegacyFallbackQuery` matters
`?legacy=true` is an explicit operator/support override. It short-circuits NextGen eligibility and guarantees a deterministic fallback path when rollback is needed without redeploying.
:::

:::note Why it matters
`resolveRouteController` is the core entry point. `shouldUseNextGenRouter` is a focused dependency used only to decide eligibility.
:::

:::note
`ProductDetail` is a route key (not a URL literal). It maps to the declarative path contract in `paths.ts`, and in production this enablement metadata is typically sourced from the feature-flag tool.
:::

### 3) Hapi â†” React Router adapter

#### 3.1) Runtime handler bridge

<CodeHeader
    path="nextgen-app/hybrid-routing/routing.ts"
    href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/hybrid-routing/routing.ts#L146"
/>
```js
const createReactRouterRoutesHandler = async (request: HapiRequest) => {
  const build = await getViteBuild();

  return createRequestHandler({
    build,
    getLoadContext: async () => ({
      request
    })
  });
};

export const getReactRouterRoutesHandler = async (request: HapiRequest): Promise<ReturnType<typeof createRequestHandler>> => {
  return await createReactRouterRoutesHandler(request);
};
```

:::note Why it matters
This is the runtime bridge used by `resolveRouteController` to defer NextGen handler creation until a request is actually eligible.
:::

:::note
`getLoadContext` is the per-request context portal. It is where Hapi runtime data is injected into React Router loaders/actions (session, request metadata, feature state, and any cross-layer runtime contract).
:::

#### 3.2) Hapi request/response adapter

<CodeHeader
  path="nextgen-app/hybrid-routing/react-router-request-response.adapter.ts"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/hybrid-routing/react-router-request-response.adapter.ts#L23"
/>
```js
export const createRequestHandler = ({
  build,
  getLoadContext,
  mode = process.env.NODE_ENV
}: {
  build: ServerBuild;
  getLoadContext?: GetLoadContextFunction;
  mode?: string;
}) => {
  const handleRequest = createReactRouterRequestHandler(build, mode);

  return async (hapiReq: HapiRequest, h: ResponseToolkit) => {
    try {
      const request = createReactRouterRequest(hapiReq);
      const loadContext = await getLoadContext?.(hapiReq, h);
      const response = await handleRequest(request, loadContext);

      return await sendReactRouterResponse(h, response);
    } catch (error) {
      logger.error("createRequestHandler", "Failure adapting request to React Router", [
        serializeLogSegment({
          method: hapiReq?.method?.toUpperCase?.() ?? hapiReq?.method,
          path: hapiReq?.path,
        }),
        serializeLogSegment(error)
      ]);

      throw error;
    }
  };
};
```

:::note Why it matters
This makes NextGen runtime pluggable without replacing Hapi server infrastructure.
:::

### 4) Vite runtime service layer

<CodeHeader
  path="nextgen-app/hybrid-routing/vite.ts"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/hybrid-routing/vite.ts#L35"
/>
```ts
let vite: ViteDevServer | null = null;

const viteDevServerSingleton = async () => {
  if (!vite) {
    vite = await createViteServer();
  }

  return vite;
};

export const getViteDevServer = viteDevServerSingleton;

export const getViteBuild = async () => {
  if (shouldRunViteDevServer()) {
    const viteDevServer = await getViteDevServer();

    return await viteDevServer.ssrLoadModule('virtual:react-router/server-build') as ServerBuild;
  }

  const viteStaticBuild = await import('../../build/server/index.mjs');

  return viteStaticBuild.importBuild();
};
```

:::note Why it matters
Singleton lifecycle avoids per-request boot cost and keeps dev/prod demo behavior deterministic.
:::

:::note Demo scope
The companion demo runtime intentionally runs only the Vite dev-server branch for simplicity. The static-build branch is shown here to preserve the full production control-flow shape.
:::

#### 4.1) Hapi `onRequest` bridge for Vite middleware

<CodeHeader
  path="server/demo-runtime-services.mjs"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/server/demo-runtime-services.mjs#L601"
/>

```js
// ...

if (shouldRunViteDevServer()) {
    /**
     * Register Vite middleware directly instead of using `Hecks.toPlugin(viteDevServer.middlewares, 'viteDevServer')`
     * avoiding catch-all duplicate route issues like:
     * "Error: New route /{expressPath*} conflicts with existing /{any*} at..."
     */
    hapiServer.ext(
      'onRequest',
      async (request, handler) => await registerViteDevMiddlewares({ hapiRequest: request, hapiHandler: handler })
    );
} else {
    hapiServer.route({
      method: 'GET',
      path: '/nextgen-assets/{param*}', // Needs to match assets config at vite.config.mts
      handler: {
        directory: {
          path: './build/client/nextgen-assets' // Needs to match assets directory structure at build/client
        }
      }
    });
}

registerRoutes(hapiServer);

await hapiServer.start();

// ...
```

:::note Why it matters
`registerViteDevMiddlewares` is a key integration point: it mounts Vite directly in Hapi request lifecycle and avoids catch-all route conflicts during dual-stack rollout.
:::

### 5) Route capability map

<CodeHeader
  path="nextgen-app/hybrid-routing/paths.ts"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/hybrid-routing/paths.ts#L1"
/>

```js
const DualPaths = {
  ProductDetail: "/pdp/:productCategory/:productName/:productId",
};

// Exclude RR internal paths from legacy resolver.
const InternalPaths = {
  ReactRouterManifest: "/__manifest",
};
```

:::note Why it matters
An explicit allowlist of dual-stack pages prevents accidental routing to NextGen for pages under migration that are not yet production-ready.
:::

## Resilience Design

1. Safe fallback path always exists (legacy controller).
2. Fallback can be user-forced (`?legacy=true`) for incidents and support workflows.
3. Runtime failures in NextGen are contained and redirected without losing the journey.
4. Wildcard fallback route guarantees unknown paths still resolve predictably.
5. Routing event logs explain decision reason (`nextgen-active`, `feature-flag-off`, `forced-by-query`, etc.).

### Resilience in Code

#### 1) Explicit operator fallback short-circuit

<CodeHeader
  path="nextgen-app/hybrid-routing/routing.ts"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/hybrid-routing/routing.ts#L133"
/>

```js
const shouldUseNextGenRouter = (request) => {
  const hasLegacyFallbackQuery = request?.url?.searchParams?.get("legacy");

  if (hasLegacyFallbackQuery) {
    return false;
  }

  // ...
};
```

:::note Why it matters
This guarantees deterministic rollback behavior from the edge of the routing decision, before modern runtime execution begins.
:::

#### 2) NextGen runtime failure boundary -> legacy redirect

<CodeHeader
  path="nextgen-app/routes/pdp.tsx"
  href="https://github.com/cromagnoli/hybrid-routing-demo/blob/main/nextgen-app/routes/pdp.tsx#L100"
/>

```tsx
const redirectToLegacyFromBoundary = () => {
  if (typeof window === "undefined") {
    return;
  }

  const url = new URL(window.location.href);
  url.searchParams.set("legacy", "true");
  url.searchParams.set("fallbackReason", "error-boundary");
  window.location.assign(url.toString());
};

class RedirectToLegacyBoundary extends React.Component {
  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch() {
    redirectToLegacyFromBoundary();
  }
}
```

:::note Why it matters
If modern rendering fails at runtime, users are automatically moved to the legacy path instead of getting a dead-end error screen.
:::

## Why Mixed TS + JS in This Case

1. NextGen routing/runtime modules are authored in TypeScript (`nextgen-app/hybrid-routing/*.ts`) and compiled before server start.
2. Legacy controllers and runtime orchestration remain JavaScript (`.mjs`) to mirror the production migration constraints.
3. This preserves architectural fidelity while still demonstrating typed contracts in the new runtime layer.

## Product Value

1. Lower migration risk with zero URL churn.
2. Faster incremental delivery by page/path, not by platform rewrite.
3. Better reliability posture through graceful degradation.
4. Easier stakeholder confidence: behavior is testable live with visible logs and HTML payload inspection.
5. Clear rollback strategy without deployment rollback (immediate traffic rollback).

## Performance Notes

1. In dev environments, the singleton NextGen runtime avoids repeated startup overhead across requests.
2. Routing checks are lightweight string/path matching plus feature-state checks.
3. Legacy remains direct path for non-enabled pages, so migration does not tax unrelated routes.
4. Adapter avoids duplicate server stacks by reusing current Hapi transport surface.

## Live Demo

### How to Run the Experience

1. The iframe starts on a legacy category page.
2. Click the product tile to open product detail.
3. Use the `NextGen Rollout Feature Flag Switch`, then click the fake browser `Reload` button to apply the current renderer.
4. Use `Trigger failure` in NextGen PDP to validate automatic fallback behavior.
5. Use `Live Server Data Editing (REST)` and reload to prove both renderers consume the same source of truth.
6. Inspect `Current iframe HTML` and `Server Log` to verify renderer ownership and routing reason.

<ProgressiveRoutingDemo />
