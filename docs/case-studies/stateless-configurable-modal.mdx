
import EditProductModalStatefulDemo from '@site/src/components/demo-modal/edit-product-modal-stateful-demo';
import EditProductModal from '@site/src/components/edit-product-modal/components/edit-product-modal';
import mockData, { highVolumeEditingItem, highVolumeModalMockData } from '@site/src/components/demo-modal/mockData';
import Pill from '@site/src/components/stub-ui-library/pill/pill';
import { EditProductErrorNotification, EditProductWarningNotification } from '@site/src/components/edit-product-modal/components/partials';
import LiveJsxPlayground from '@site/src/components/live-jsx-playground/live-jsx-playground';

export const firstSku = mockData.skuVariants.availableSkus[0];
export const secondSku = mockData.skuVariants.availableSkus[4];

export const demoItem = {
  productName: mockData.productSummary.displayName,
  productUrl: `/products/${mockData.productSummary.productId}`,
  imageUrl: mockData.skuVariants.imagesByColorCode[firstSku.colorCode][0],
  colorCode: firstSku.colorCode,
  size: firstSku.size,
};

export const demoItemAlt = {
  productName: mockData.productSummary.displayName,
  productUrl: `/products/${mockData.productSummary.productId}`,
  imageUrl: mockData.skuVariants.imagesByColorCode[secondSku.colorCode][0],
  colorCode: secondSku.colorCode,
  size: secondSku.size,
};

export const defaultScenarioPlaygroundCode = `() => {
  const localData = {
    productSummary: {
      productId: "${mockData.productSummary.productId}",
      displayName: "BuyMeNot Sneakers",
    },
    skuVariants: {
      colors: [
        { colorCode: "ffffff", displayName: "White", available: true },
        { colorCode: "444444", displayName: "Graphite", available: true },
      ],
      sizes: [
        { size: "10", available: true },
        { size: "11", available: true },
        { size: "12", available: true },
      ],
      availableSkus: [
        { id: "1", colorCode: "ffffff", size: "10", listPrice: "128.00", salePrice: "98.00", available: true },
        { id: "2", colorCode: "ffffff", size: "11", listPrice: "128.00", available: false },
        { id: "3", colorCode: "ffffff", size: "12", listPrice: "128.00", available: true },
        { id: "4", colorCode: "444444", size: "10", listPrice: "128.00", available: false },
        { id: "5", colorCode: "444444", size: "11", listPrice: "128.00", available: true },
        { id: "6", colorCode: "444444", size: "12", listPrice: "128.00", available: true },
      ],
      imagesByColorCode: {
        "ffffff": [...mockData.skuVariants.imagesByColorCode["ffffff"]],
        "444444": [...mockData.skuVariants.imagesByColorCode["444444"]],
      },
    },
  };

  const initialSku = localData.skuVariants.availableSkus[0];

  const demoItem = {
    productName: localData.productSummary.displayName,
    productUrl: "/products/" + localData.productSummary.productId,
    imageUrl: localData.skuVariants.imagesByColorCode[initialSku.colorCode][0],
    colorCode: initialSku.colorCode,
    size: initialSku.size,
  };

  return (
    <EditProductModalStatefulDemo
      editingItem={demoItem}
      mockModalData={localData}
      renderAfterHeading={() => <Pill>NEW</Pill>}
    />
  );
}`;

export const highVolumeScenarioPlaygroundCode = `() => {
  const localData = ${JSON.stringify(highVolumeModalMockData, null, 2)};

  const defaultSku = {
    id: "hv-10-4",
    colorCode: "22c55e",
    size: "6.5",
    listPrice: "138.00",
    salePrice: "118.00",
    available: false,
  };

  const editingItem = {
    productName: localData.productSummary.displayName,
    productUrl: "/products/" + localData.productSummary.productId,
    imageUrl: localData.skuVariants.imagesByColorCode[defaultSku.colorCode][0],
    colorCode: defaultSku.colorCode,
    size: defaultSku.size,
  };

  return (
    <EditProductModalStatefulDemo
      editingItem={editingItem}
      mockModalData={localData}
    />
  );
}`;

# Stateless Configurable Modal

This demo showcases a stateless, configurable modal architecture using
derived availability logic and render prop injection.

> Note: This modal's visual styles were adjusted to work inline inside documentation.  
> The production implementation used a different presentation and should not be inferred from this demo styling.  
> External dependencies that are not accessible in this environment are lightly stubbed for demo purposes.  
> Data fetching is mocked for demonstration, and latency is simulated with a timer.

---

<div className="demoSection">
  <h3>Default Behavior</h3>
  <small className="subtle-attention-text">Resize to see responsive behavior from mobile through desktop.</small>
  <EditProductModalStatefulDemo
    editingItem={demoItem}
    renderAfterHeading={() => <Pill>NEW</Pill>}
  />
</div>

<LiveJsxPlayground
  title="Default Scenario Playground"
  initialCode={defaultScenarioPlaygroundCode}
  scope={{
    EditProductModalStatefulDemo,
    Pill,
    mockData,
  }}
/>

<div className="demoSection">
  <h3>Second Scenario</h3>
  <small className="subtle-attention-text">Resize to see responsive behavior from mobile through desktop.</small>
  <EditProductModalStatefulDemo
    editingItem={demoItemAlt}
    renderNotifications={({ isCurrentSkuAvailable, currentMatchingSkuId }) => (
      <>
        <EditProductWarningNotification visible={currentMatchingSkuId === '5'}>
          Hurry up! Limited units remaining!
        </EditProductWarningNotification>
        <EditProductErrorNotification visible={!isCurrentSkuAvailable}>
          Sold out. Please select another combination.
        </EditProductErrorNotification>
      </>
    )}
  />
</div>

<div className="demoSection">
  <h3>High-Volume Options Demo</h3>
  <small>Fake fetch with 12 colors x 25 sizes (US 5.0-9.5, then whole sizes 10-24) to stress selector overflow and composition.</small>
  <EditProductModalStatefulDemo
    editingItem={highVolumeEditingItem}
    mockModalData={highVolumeModalMockData}
  />
</div>

<LiveJsxPlayground
  title="High-Volume Scenario Playground"
  initialCode={highVolumeScenarioPlaygroundCode}
  scope={{
    EditProductModalStatefulDemo,
    highVolumeModalMockData,
  }}
/>

<div className="demoSection">
  <h3>Loading State Demo</h3>
  <small>
    Available information is rendered immediately, while the section that depends on remote data is hidden until the response arrives and that part can be fully composed. Because users already have content to scan, they begin engaging right away, which reduces perceived waiting time and lowers anxiety about loading delays.
  </small>
  <EditProductModal
    mainHeading="BuyMeNot Sneakers"
    productName="BuyMeNot Sneakers"
    initialImageUrl={mockData.skuVariants.imagesByColorCode[firstSku.colorCode][0]}
    initialColorCode={null}
    initialSize={null}
    initialListPrice={firstSku.listPrice}
    initialSalePrice={firstSku.salePrice}
    currencyCode="USD"
    skuVariants={{}}
    locale={{ lang: 'en', countryCode: 'US' }}
    onDismiss={() => {}}
  />
</div>

<div className="demoSection">
  <h3>Loading Variant: Missing Core Display Context</h3>
  <small>
    This variant intentionally omits image, heading, product name, color and size to show the fallback loading shell when the consumer has almost no initial context.
  </small>
  <EditProductModal
    mainHeading=""
    productName=""
    initialImageUrl={null}
    initialColorCode={firstSku.colorCode}
    initialSize={firstSku.size}
    initialListPrice={null}
    initialSalePrice={null}
    currencyCode="USD"
    skuVariants={{}}
    locale={{ lang: 'en', countryCode: 'US' }}
    onDismiss={() => {}}
  />
</div>
